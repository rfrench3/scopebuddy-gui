#PySide6, Qt Designer UI files
from PySide6.QtWidgets import QApplication, QMainWindow, QDialog
from PySide6.QtGui import QIntValidator
from ui_mainwindow import Ui_MainWindow  # Import generated UI file
from ui_about import Ui_Dialog_About  # Import generated UI file
from ui_apply_confirmation import Ui_Dialog_Apply

# non-GUI imports
import sys  
import os
from re import search # for searching for gamescope args in the config file
import subprocess # for running the shell script that finds gamescope and scopebuddy

class MainWindow(QMainWindow): 
    def __init__(self):
        super().__init__()
        self.ui = Ui_MainWindow() # imported from ui_mainwindow.py, generated by Qt Designer using mainwindow.ui
        self.ui.setupUi(self)
        self.setWindowTitle("ScopeBuddy GUI")  # Set the window title
        self.ui.variable_displayGamescope.setText(f'Current Gamescope Config: {self.get_gamescope_args()}') #display the current gamescope args

        # Button actions
        self.ui.pushButton_apply.clicked.connect(self.apply_clicked)
        self.ui.pushButton_exit.clicked.connect(self.exit_app)
        self.ui.pushButton_about.clicked.connect(self.open_about_dialog)

        # Input field validation 
        self.ui.lineEdit_oHeight.setValidator(QIntValidator()) # ensures valid inputs.
        self.ui.lineEdit_rHeight.setValidator(QIntValidator()) # input fields are also limited to 
        self.ui.lineEdit_oWidth.setValidator(QIntValidator())  # 4 digits in Qt Designer to ensure sane configs,
        self.ui.lineEdit_rWidth.setValidator(QIntValidator())  # unless a different value is more logical.
        self.ui.lineEdit_fps.setValidator(QIntValidator())
        self.ui.lineEdit_maxScaleFactor.setValidator(QIntValidator())
        self.ui.lineEdit_upscalerSharpness.setValidator(QIntValidator())

        gamescope_path = locate_dependency('gamescope') # check if gamescope is installed
        scopebuddy_path = locate_dependency('scopebuddy')
        if not (gamescope_path and scopebuddy_path):
            self.ui.variable_displayGamescope.setText("Gamescope or ScopeBuddy not found, no changes made will be saved.")
            self.ui.variable_displayGamescope.setStyleSheet("color: red;")



    def get_gamescope_args(self) -> str: #search for the config file, return args if it exists
        # Check if the config file exists
        if not os.path.exists(os.path.expanduser('~/.config/scopebuddy/scb.conf')):
            print("Config file does not exist, generating basic file...")
            #generates new config file with default values
            with open(os.path.expanduser('~/.config/scopebuddy/scb.conf'),'w') as file:
                # Create the config file with default values
                file.write("# ScopeBuddy configuration file\n")
                file.write("# This file is automatically generated by ScopeBuddy-GUI\n")
                file.write("# Feel free to edit this file manually, and check the scopebuddy github for more details. https://github.com/HikariKnight/ScopeBuddy\n")
                file.write("SCB_GAMESCOPE_ARGS=\"-w 1920 -h 1080 -r 60 -e\"\n")
                file.write("# this default enables the steam overlay and tells games to render to 1080p 60fps\n")

        # The file does exist, so read it and return the gamescope arguments
        with open(os.path.expanduser('~/.config/scopebuddy/scb.conf'), 'r') as file: #read-only mode, this part does not write to the file
            lines = file.readlines()
            for line in lines:
                if line.startswith('SCB_GAMESCOPE_ARGS='):
                    match = search(r'SCB_GAMESCOPE_ARGS="([^"]*)"', line)
                    if match:
                        return match.group(1)
                    else:
                        print("No SCB_GAMESCOPE_ARGS found in the config file.")
                        return None #TODO: make it add a line for the args
        

    def generate_new_config(self) -> str: #output a new config string based on the user input
        self.config_list = []

        def apply_lineEdit_input(lineEdit:int, arg):
            if lineEdit.text().isdigit():
                self.config_list.append(f'{arg} {lineEdit.text()} ')                
            
        def apply_combobox_input(comboBox, arg): #appends combobox input to the config list (unless default)
            if comboBox.currentIndex() != 0:
                self.config_list.append(f'{arg} {comboBox.currentText()} ')

        def apply_checkbox_input(checkBox, arg): #appends checkbox input to the config list 
            if checkBox.isChecked():
                self.config_list.append(f'{arg} ')

        def apply_doubleSpinBox_input(doubleSpinBox, arg): #preferred for float values
            if doubleSpinBox.value() != 1.0:
                self.config_list.append(f'{arg} {doubleSpinBox.value()} ')

        def compile_arguments(settings):
            for widget_type, input_widget, arg in settings:
                if widget_type == 'checkbox':
                    apply_checkbox_input(input_widget, arg)
                elif widget_type == 'lineEdit':
                    apply_lineEdit_input(input_widget, arg)
                elif widget_type == 'comboBox':
                    apply_combobox_input(input_widget, arg)
                elif widget_type == 'doubleSpinBox':
                    apply_doubleSpinBox_input(input_widget, arg)
                else:
                    raise NotImplementedError(f"Widget type '{widget_type}' is not implemented.")

        # IMPLEMENTED ARGUMENTS
        settings = [
            ('checkbox', self.ui.checkBox_mango, '--mangoapp'),
            ('lineEdit', self.ui.lineEdit_rHeight, '-h'),
            ('lineEdit', self.ui.lineEdit_rWidth, '-w'),
            ('lineEdit', self.ui.lineEdit_fps, '-r'),
            ('checkbox', self.ui.checkBox_fullscreen, '-f'),
            ('lineEdit', self.ui.lineEdit_oHeight, '-H'),
            ('lineEdit', self.ui.lineEdit_oWidth, '-W'),
            ('checkbox', self.ui.checkBox_steam, '-e'),
            ('checkbox', self.ui.checkBox_hdr, '--hdr-enabled'),
            ('lineEdit', self.ui.lineEdit_maxScaleFactor, '-m'),
            ('comboBox', self.ui.comboBox_upscalerType, '-S'),
            ('comboBox', self.ui.comboBox_upscalerFilter, '-F'),
            ('lineEdit', self.ui.lineEdit_upscalerSharpness, '--sharpness'),
            ('doubleSpinBox', self.ui.doubleSpinBox_mouseSensitivity, '-s'),
            ('checkbox', self.ui.checkBox_adaptiveSync, '--adaptive-sync'),
            ('checkbox', self.ui.checkBox_forceInternalFullscreen, '--force-windows-fullscreen'),
        ]

        compile_arguments(settings)


        generated_config = ''
        for argument in self.config_list:
            generated_config += argument
        
        print(f'The generated config file is {generated_config}')
        return generated_config

    def apply_global_config(self):
        # set the config
        the_config = self.generate_new_config()

        # Open the config file
        with open(os.path.expanduser('~/.config/scopebuddy/scb.conf'), 'r') as file:
            lines = file.readlines()

            # Find the line that starts with SCB_GAMESCOPE_ARGS
            for i, line in enumerate(lines):
                if line.startswith('SCB_GAMESCOPE_ARGS'):
                    commented_line = f"# commented out by scopebuddy-gui: {line}"# Comment out the original line
                    new_line = f'SCB_GAMESCOPE_ARGS="{the_config}"\n'# Create the new line
                    lines[i:i+1] = [commented_line, new_line]# Replace with the commented + new line
                    break

            # Write the modified lines back to the file
            with open(os.path.expanduser('~/.config/scopebuddy/scb.conf'), 'w') as file:
                file.writelines(lines)

        self.ui.variable_displayGamescope.setText(f'Current Gamescope Config: {self.get_gamescope_args()}') #display updated config

    def ensure_valid_args(self) -> tuple:
        pass  #TODO: ensure the set of inputs is valid (-h cant be empty unless -w is empty, etc.)

    # ON-CLICK METHODS

    def apply_clicked(self):
        print("Apply button clicked...")
        if not self.ensure_valid_args():
            #TODO: dialog telling user what to fix
            pass
        dialog = DialogApply()
        dialog.exec()
        if dialog.answer:
            print('Applying changes...')
            self.apply_global_config()

    def exit_app(self):
        print("Exiting application...")
        sys.exit()

    def open_about_dialog(self):
        print("Opening about dialog...")
        dialog = DialogAbout()
        dialog.exec() #TODO: popup can go behind the main window, while blocking inputs on the main window...


class DialogAbout(QDialog):
    def __init__(self):
        super().__init__()
        self.ui = Ui_Dialog_About()
        self.ui.setupUi(self)
        self.setWindowTitle("About ScopeBuddy GUI")  # Set the window title
        self.ui.pushButton_okay.clicked.connect(self.exit_app)
    
    def exit_app(self):
        self.close()

class DialogApply(QDialog):
    def __init__(self):
        super().__init__()
        self.ui = Ui_Dialog_Apply()
        self.ui.setupUi(self)
        self.setWindowTitle("Apply Changes?")  # Set the window title
        self.ui.var_currentConfig.setText(MainWindow.get_gamescope_args(window))
        self.ui.var_newConfig.setText(MainWindow.generate_new_config(window))

        #button actions
        self.ui.pushButton_Cancel.clicked.connect(self.exit_window)
        self.ui.pushButton_Apply.clicked.connect(self.apply_changes)
        self.answer = False #changes will not be applied unless explictly confirmed
        
        if not (locate_dependency('gamescope') and locate_dependency('scopebuddy')):
            print("Gamescope or ScopeBuddy not found, disabling file writing.")
            self.ui.pushButton_Apply.setEnabled(False)
            self.ui.label.setText("Gamescope or ScopeBuddy not found, unable to write to config file.")
            self.ui.label.setStyleSheet("color: red;")
            self.ui.label_4.setText('Ensure they are properly installed for this program to work.')
    
    def exit_window(self):
        self.close()
    
    def apply_changes(self):
        self.answer = True #changes have been explicitly confirmed
        self.close()

# return path to program if it exists, None if it doesn't. for determining if gamescope/scopebuddy are installed
def locate_dependency(program:str):
    # Check if the required dependency is installed
    try:
        # Run the shell script and capture the output
        result = subprocess.run(["./locatepath.sh", program], capture_output=True, text=True)
        print(result.stdout)
        return result.stdout
    except Exception:
        print(f"Error, Unable to run the shell script due to: {Exception}")
        return None



app = QApplication([]) # pass the arguments to the QApplication constructor
window = MainWindow()
window.show()
app.exec()

